#!/usr/bin/env python3
"""
Claude - Interface de chat interativo para o Claude Code SDK.
Digite suas mensagens e pressione Enter para enviar.
"""

import sys
import asyncio
import os
import json
import requests
from pathlib import Path
from datetime import datetime

# Adiciona o diretÃ³rio ao path
parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, parent_dir)

from src import AssistantMessage, TextBlock, ResultMessage, ClaudeSDKClient, __version__

# ConfiguraÃ§Ãµes do viewer
VIEWER_API_URL = "http://localhost:3043"

async def get_sessions():
    """Busca sessÃµes do viewer HTTP."""
    try:
        response = requests.get(f"{VIEWER_API_URL}/api/sessions", timeout=5)
        if response.status_code == 200:
            return response.json()
        else:
            print(f"âŒ Erro HTTP {response.status_code} ao carregar sessÃµes")
            return []
    except requests.exceptions.ConnectionError:
        print(f"âŒ NÃ£o foi possÃ­vel conectar ao viewer em {VIEWER_API_URL}")
        print("ğŸ’¡ Certifique-se de que o viewer estÃ¡ rodando")
        return []
    except Exception as e:
        print(f"âŒ Erro ao carregar sessÃµes: {str(e)}")
        return []

async def session_browser():
    """Interface de navegaÃ§Ã£o de sessÃµes no CLI."""
    print("\n" + "=" * 60)
    print("ğŸ” NAVEGADOR DE SESSÃ•ES")
    print("=" * 60)
    
    sessions = await get_sessions()
    if not sessions:
        input("\nğŸ“­ Nenhuma sessÃ£o encontrada. Pressione Enter para continuar...")
        return
    
    print(f"ğŸ“Š {len(sessions)} sessÃµes encontradas")
    
    while True:
        print("\n" + "-" * 60)
        print("ğŸ” OPÃ‡Ã•ES:")
        print("1. ğŸ“‹ Listar todas as sessÃµes")
        print("2. ğŸ” Buscar sessÃ£o por ID")
        print("3. ğŸ“ Filtrar por diretÃ³rio/projeto")
        print("4. ğŸŒ Abrir sessÃ£o no viewer web")
        print("5. ğŸ“ Gerar resumo de sessÃ£o")
        print("0. â¬…ï¸  Voltar ao chat")
        
        try:
            choice = input("\nğŸ‘¤ Escolha uma opÃ§Ã£o: ").strip()
        except EOFError:
            break
            
        if choice == "0":
            break
        elif choice == "1":
            await list_sessions(sessions)
        elif choice == "2":
            await search_session(sessions)
        elif choice == "3":
            await filter_by_directory(sessions)
        elif choice == "4":
            await open_in_web(sessions)
        elif choice == "5":
            await generate_summary(sessions)
        else:
            print("âŒ OpÃ§Ã£o invÃ¡lida")

async def list_sessions(sessions, limit=20):
    """Lista sessÃµes com paginaÃ§Ã£o."""
    print(f"\nğŸ“‹ LISTAGEM DE SESSÃ•ES (Ãºltimas {min(limit, len(sessions))})")
    print("-" * 60)
    
    # Ordenar por Ãºltima interaÃ§Ã£o (mais recentes primeiro)
    sorted_sessions = sorted(sessions, key=lambda x: x.get('last_interaction', ''), reverse=True)
    
    for i, session in enumerate(sorted_sessions[:limit]):
        directory_short = session['directory'].split('/')[-1] if '/' in session['directory'] else session['directory']
        print(f"{i+1:2d}. ğŸ“„ {session['session_id'][:12]}... | ğŸ“ {directory_short} | â° {session.get('last_interaction', 'N/A')}")
    
    if len(sessions) > limit:
        print(f"\n... e mais {len(sessions) - limit} sessÃµes")
    
    input("\nPressione Enter para continuar...")

async def search_session(sessions):
    """Busca sessÃ£o por ID parcial."""
    try:
        search_term = input("\nğŸ” Digite parte do ID da sessÃ£o: ").strip().lower()
    except EOFError:
        return
        
    if not search_term:
        return
    
    matches = [s for s in sessions if search_term in s['session_id'].lower()]
    
    if not matches:
        print(f"âŒ Nenhuma sessÃ£o encontrada com '{search_term}'")
        input("Pressione Enter para continuar...")
        return
    
    print(f"\nğŸ¯ {len(matches)} sessÃ£o(Ãµes) encontrada(s):")
    print("-" * 60)
    
    for i, session in enumerate(matches):
        directory_short = session['directory'].split('/')[-1] if '/' in session['directory'] else session['directory']
        print(f"{i+1}. ğŸ“„ {session['session_id']} | ğŸ“ {directory_short}")
    
    if len(matches) == 1:
        await show_session_details(matches[0])
    else:
        input("\nPressione Enter para continuar...")

async def filter_by_directory(sessions):
    """Filtra sessÃµes por diretÃ³rio/projeto."""
    directories = sorted(list(set(s['directory'] for s in sessions)))
    
    print(f"\nğŸ“ DIRETÃ“RIOS/PROJETOS ({len(directories)} encontrados):")
    print("-" * 60)
    
    for i, directory in enumerate(directories):
        session_count = sum(1 for s in sessions if s['directory'] == directory)
        directory_short = directory.split('/')[-1] if '/' in directory else directory
        print(f"{i+1:2d}. ğŸ“ {directory_short} ({session_count} sessÃµes)")
    
    try:
        choice = input(f"\nğŸ‘¤ Escolha um diretÃ³rio (1-{len(directories)}): ").strip()
        dir_idx = int(choice) - 1
        
        if 0 <= dir_idx < len(directories):
            selected_dir = directories[dir_idx]
            filtered_sessions = [s for s in sessions if s['directory'] == selected_dir]
            await list_sessions(filtered_sessions, 50)  # Mostrar mais sessÃµes do diretÃ³rio selecionado
        else:
            print("âŒ NÃºmero invÃ¡lido")
            input("Pressione Enter para continuar...")
    except (ValueError, EOFError):
        print("âŒ Entrada invÃ¡lida")
        input("Pressione Enter para continuar...")

async def open_in_web(sessions):
    """Abre sessÃ£o selecionada no browser web."""
    try:
        session_id = input("\nğŸŒ Digite o ID da sessÃ£o (ou parte): ").strip()
    except EOFError:
        return
        
    if not session_id:
        return
    
    matches = [s for s in sessions if session_id.lower() in s['session_id'].lower()]
    
    if not matches:
        print(f"âŒ SessÃ£o '{session_id}' nÃ£o encontrada")
        input("Pressione Enter para continuar...")
        return
    
    if len(matches) > 1:
        print(f"âš ï¸  MÃºltiplas sessÃµes encontradas ({len(matches)}). Use um ID mais especÃ­fico.")
        for session in matches[:5]:  # Mostrar apenas 5 primeiros
            print(f"   ğŸ“„ {session['session_id']}")
        input("Pressione Enter para continuar...")
        return
    
    session = matches[0]
    await show_session_details(session)

async def show_session_details(session):
    """Mostra detalhes de uma sessÃ£o especÃ­fica."""
    print("\n" + "=" * 60)
    print("ğŸ“„ DETALHES DA SESSÃƒO")
    print("=" * 60)
    
    print(f"ğŸ†” ID: {session['session_id']}")
    print(f"ğŸ“ DiretÃ³rio: {session['directory']}")
    print(f"â° Ãšltima interaÃ§Ã£o: {session.get('last_interaction', 'N/A')}")
    print(f"ğŸ“‚ Arquivo: {session.get('file_path', 'N/A')}")
    
    # Carregar estatÃ­sticas se possÃ­vel
    file_path = Path(session.get('file_path', ''))
    if file_path.exists():
        try:
            with open(file_path, 'r') as f:
                lines = f.readlines()
            
            user_msgs = sum(1 for line in lines if '"type":"user"' in line)
            assistant_msgs = sum(1 for line in lines if '"type":"assistant"' in line)
            
            print(f"ğŸ“Š EstatÃ­sticas:")
            print(f"   ğŸ“„ Linhas no arquivo: {len(lines)}")
            print(f"   ğŸ‘¤ Mensagens usuÃ¡rio: {user_msgs}")
            print(f"   ğŸ¤– Respostas Claude: {assistant_msgs}")
            print(f"   ğŸ’¬ Total mensagens: {user_msgs + assistant_msgs}")
            
        except Exception as e:
            print(f"âŒ Erro ao ler estatÃ­sticas: {str(e)}")
    
    print(f"\nğŸŒ URLs disponÃ­veis:")
    base_url = f"{VIEWER_API_URL}/{session['directory']}/{session['session_id']}"
    print(f"   ğŸ“„ Ver sessÃ£o: {base_url}")
    print(f"   ğŸ“ Resumo conciso: {base_url}/resumo?tipo=conciso")
    print(f"   ğŸ“‹ Resumo detalhado: {base_url}/resumo?tipo=detalhado")
    
    input("\nPressione Enter para continuar...")

async def generate_summary(sessions):
    """Gera resumo de uma sessÃ£o."""
    try:
        session_id = input("\nğŸ“ Digite o ID da sessÃ£o para resumo (ou parte): ").strip()
    except EOFError:
        return
        
    if not session_id:
        return
    
    matches = [s for s in sessions if session_id.lower() in s['session_id'].lower()]
    
    if not matches:
        print(f"âŒ SessÃ£o '{session_id}' nÃ£o encontrada")
        input("Pressione Enter para continuar...")
        return
    
    if len(matches) > 1:
        print(f"âš ï¸  MÃºltiplas sessÃµes encontradas ({len(matches)}). Use um ID mais especÃ­fico.")
        input("Pressione Enter para continuar...")
        return
    
    session = matches[0]
    
    print(f"\nğŸ“ Tipos de resumo disponÃ­veis:")
    print("1. ğŸ“ Conciso (20 palavras)")
    print("2. ğŸ“‹ Detalhado (400 palavras)") 
    print("3. â€¢ Bullet Points")
    
    try:
        choice = input("ğŸ‘¤ Escolha o tipo (1-3): ").strip()
        
        types_map = {"1": "conciso", "2": "detalhado", "3": "bullet_points"}
        summary_type = types_map.get(choice)
        
        if not summary_type:
            print("âŒ OpÃ§Ã£o invÃ¡lida")
            input("Pressione Enter para continuar...")
            return
        
        print(f"\nğŸ¤– Gerando resumo {summary_type}...")
        
        payload = {
            "directory": session['directory'],
            "session_id": session['session_id'],
            "summary_type": summary_type
        }
        
        response = requests.post(f"{VIEWER_API_URL}/api/summarize", json=payload, timeout=60)
        
        if response.status_code == 200:
            result = response.json()
            if result.get('success'):
                print(f"\nâœ… Resumo gerado com sucesso:")
                print("-" * 60)
                print(result.get('summary', ''))
                print("-" * 60)
            else:
                print(f"âŒ Erro na API: {result.get('error')}")
        else:
            print(f"âŒ Erro HTTP {response.status_code}")
            
    except (ValueError, EOFError, requests.RequestException) as e:
        print(f"âŒ Erro: {str(e)}")
    
    input("\nPressione Enter para continuar...")

async def chat_mode():
    """Modo chat interativo com contexto mantido."""
    print("=" * 60)
    print(f"ğŸ¤– Claude Code SDK Python v{__version__} - Chat Interativo")
    print("=" * 60)
    print("ğŸ’¬ Digite suas mensagens e pressione Enter para enviar")
    print("ğŸ“ Comandos: 's' ou 'sair' para sair, Ctrl+I para interromper")
    print("ğŸ”„ Comandos: 'l' ou 'limpar', 'n' ou 'novo' para limpar contexto")
    print("ğŸ” Comandos: 'v' ou 'viewer' para navegar sessÃµes")
    print("-" * 60)
    
    client = ClaudeSDKClient()
    await client.connect()
    
    try:
        while True:
            # Aguarda input do usuÃ¡rio
            try:
                prompt = input("\nğŸ‘¤ VocÃª: ").strip()
            except EOFError:
                break
                
            if not prompt:
                continue
                
            # Comandos especiais
            if prompt.lower() in ['s', 'sair']:
                print("ğŸ‘‹ AtÃ© logo!")
                break
            
            if prompt.lower() in ['l', 'limpar', 'n', 'novo']:
                print("ğŸ”„ Contexto limpo. Iniciando nova conversa...")
                await client.disconnect()
                client = ClaudeSDKClient()
                await client.connect()
                continue
            
            if prompt.lower() in ['v', 'viewer']:
                await session_browser()
                continue
            
            # Envia query e mostra resposta
            print("-" * 40)
            try:
                await client.query(prompt)
                
                async for message in client.receive_response():
                    if isinstance(message, AssistantMessage):
                        print("ğŸ¤– Claude: ", end="")
                        for block in message.content:
                            if isinstance(block, TextBlock):
                                print(block.text)
                    elif isinstance(message, ResultMessage):
                        if hasattr(message, 'usage') and message.usage:
                            tokens_info = ""
                            if hasattr(message.usage, 'input_tokens'):
                                tokens_info = f"[Tokens: {message.usage.input_tokens}â†‘ {message.usage.output_tokens}â†“]"
                            elif isinstance(message.usage, dict):
                                tokens_info = f"[Tokens: {message.usage.get('input_tokens', 0)}â†‘ {message.usage.get('output_tokens', 0)}â†“]"
                            if tokens_info:
                                print(f"\n{tokens_info}", end="")
                        if hasattr(message, 'total_cost_usd') and message.total_cost_usd:
                            print(f" [Custo: ${message.total_cost_usd:.6f}]")
                        
            except Exception as e:
                print(f"âŒ Erro: {e}")
                
    except KeyboardInterrupt:
        print("\n\nğŸ‘‹ Interrompido!")
    finally:
        await client.disconnect()

if __name__ == "__main__":
    # Desabilita buffer do output
    sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 1)
    sys.stderr = os.fdopen(sys.stderr.fileno(), 'w', 1)
    
    # Sempre executa modo chat
    try:
        asyncio.run(chat_mode())
    except KeyboardInterrupt:
        print("\nğŸ‘‹ AtÃ© logo!")
        sys.exit(0)
    except Exception as e:
        print(f"âŒ Erro fatal: {e}")
        sys.exit(1)
    finally:
        sys.exit(0)